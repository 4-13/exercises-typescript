---

name: Иерархия типов
theory: |

  В определении системы типов есть несколько подходов, например, считать каждый тип отдельной вселенной и давать на откуп пользователям определение всех взаимодействий между ними. Или другой подход, когда вселенная одна и внутри нее есть более мелкие единицы.

  Второй подход как раз про TypeScript, как и, например, про Java, где все наследуется от `Object``.

  Первый же подход хорошо описывается теорией множеств. Здесь одну из ключевых ролей играют подмножества и надмножества. Множество `A` является подмножеством `B`, если любой элемент принадлежащий `A` также принадлежит `B`. Эта идея также отлично описывает идею связи между типами, создавая тем самым иерархию типов, которая в свою очередь определяет возможность присвоить переменную одного типа переменной другого типа.

  В уроке про литеральные типы мы сказали, что они существуют для трех типов данных: `boolean`, `string`, `number`. Таким образом любой литеральный тип мы можем присвоить переменной соответствующего типа:

  ```typescript
  let num: number = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  num = two;
  num = notTrue; // Type 'boolean' is not assignable to type 'number'.
  ```

  Анализатор успешно пропустил присваивание литерального типа числа к `number`, но литеральный `boolean` тип мы уже не смогли присвоить. Для того, чтобы решить эту проблему мы могли бы использовать объединение типов `number | boolean`, но если мы не уверенны, что может быть присвоено, то нам пришлось бы делать объединение с потенциально огромным числом типов.

  Тут нам приходит на помощь тип `unknown`, представляющий собой надмножество всех доступных типов, который позволяет присвоить переменной значение значение произвольного типа:

  ```typescript
  let unknownValue: unknown = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  unknownValue = two;
  unknownValue = notTrue; // OK
  ```

  Куда более редкий случай на практики, когда нам нужно быть уверенными, что переменной не будет присвоено никакого значения, позволяет реализовать тип `never`. С точки зрения теории множеств, это пустое множество, не содержащее никакого элемента:

  ```typescript
  let neverValue: never;
  const two: 2 = 2;

  neverValue = two; // Type 'number' is not assignable to type 'never'
  ```

  Из текущих знаний мы можем составить следующую картинку множества типов TypeScript:

  <!-- TODO: добавить картинку -->

  ```typescript
  type StringNumber = number | string;

  let value: StringNumber = 10;
  value = 'string'
  ```

  <!-- TODO: добавить картинку с кругами Эйлера -->

instructions: |

tips:
  - |
    [Дерево иерархии типов](https://www.zhenghao.io/posts/type-hierarchy-tree)
