---

name: Null и Undefined
theory: |

  В TypeScript `null` и `undefined` не просто значения, а два типа, состоящие из одного значения. Зачем так сделано? Представьте, если бы TypeScript работал похожим образом на JavaScript, то есть эти значения можно было бы передавать в любом месте, не важно что там ожидается, строка, массив и тому подобное. К чему бы привело такое поведение?

  Варианта здесь два. Либо возникновение ошибки "вызывается несуществующий метод". Такая проблема например существует в JavaScript:

  ```javascript
  function foo(value) {
    const upperValue = value.toUpperCase();
    // остальная логика
  }

  foo(null); // Uncaught TypeError: Cannot read properties of null (reading 'toUpperCase')
  ```

  В TypeScript подобная проверка встроена:

  ```typescript
  function foo(value?: string | null) {
    const upperValue = value.toUpperCase(); // Object is possibly 'null' or 'undefined'.
    // остальная логика
  }
  ```

  Компилятор требует написать соответствующее условие, что позволяет избежать ошибок во время исполнения кода:

  ```typescript
  function foo(value?: string | null) {
    if (value !== null && value !== undefined) {
      const upperValue = value.toUpperCase();
      //                 ^? (parameter) value: string
    }
    // остальная логика
  }
  ```

  Это стало возможным как раз благодаря выделению значений `null` и `undefined` в отдельные типы, а благодаря Narrowing и Union Types не пришлось изобретать дополнительный механизм. И все решение укладывается в концепцию "типы как множества". Благодаря каждой проверке мы отсекаем не подходящее нам множество значений и получаем безопасный вызов метода. Такие проверки также называются отсечением типов (Differentiating Types) и Type Guards.

instructions: |
  Реализуйте функцию `formatPrice()`, которая принимает число и возвращает строку с округлением до второго числа после запятой, если пришел `null` или `undefined` должна вернуться `'$0.00'`.

  ```typescript
  formatPrice(3.145); // '$3.15'
  formatPrice(200); // '$200.00'
  formatPrice() // '$0.00'
  formatPrice(null) // '$0.00'
  ```
